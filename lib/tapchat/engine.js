// Generated by CoffeeScript 1.3.3
(function() {
  var B, BacklogDB, Base64, Buffer, CoffeeScript, Config, Connection, Crypto, Daemon, DataBuffer, Engine, Express, Fs, Http, LocalStrategy, Log, Passport, PasswordHash, Path, PushClient, SessionStore, Url, Util, WebSocket, WorkingQueue, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  WorkingQueue = require('capisce').WorkingQueue;

  Http = require('http');

  Passport = require('passport');

  LocalStrategy = require('passport-local').Strategy;

  Express = require('express');

  Url = require('url');

  WebSocket = require('faye-websocket');

  PasswordHash = require('password-hash');

  CoffeeScript = require('coffee-script');

  Util = require('util');

  Daemon = require('daemon');

  Crypto = require('crypto');

  _ = require('underscore');

  DataBuffer = require('buffer').Buffer;

  Log = require('./log');

  Base64 = require('../base64');

  Config = require('./config');

  B = require('./message_builder');

  Buffer = require('./buffer');

  Connection = require('./connection');

  BacklogDB = require('./backlog_db');

  PushClient = require('./push_client');

  SessionStore = require('./session_store');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  Engine = (function() {

    function Engine(config, callback) {
      var _this = this;
      this.connections = [];
      this.clients = [];
      this.password = config.password;
      this.port = config.port;
      if (!PasswordHash.isHashed(this.password)) {
        throw 'No password set!';
      }
      this.pushId = config.push_id;
      this.pushKey = new DataBuffer(config.push_key, 'base64');
      this.pushClient = new PushClient(this);
      this.db = new BacklogDB(this, function() {
        _this.startServer(_this.port, callback);
        return _this.db.selectConnections(function(conns) {
          var connInfo, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = conns.length; _i < _len; _i++) {
            connInfo = conns[_i];
            _results.push(_this.addConnection(connInfo));
          }
          return _results;
        });
      });
    }

    Engine.prototype.daemonize = function() {
      var logfile, pidfile;
      logfile = Config.getLogFile();
      pidfile = Config.getPidFile();
      this.pid = Daemon.daemonize(logfile, pidfile);
      return Log.info("Daemon started successfully with pid: " + this.pid + "}");
    };

    Engine.prototype.startServer = function(port, callback) {
      var _this = this;
      Passport.use(new LocalStrategy(function(username, password, done) {
        if (!PasswordHash.verify(password, _this.password)) {
          return done(null, false, {
            message: 'Invalid password'
          });
        }
        return done(null, {});
      }));
      this.sessions = new SessionStore(Path.join(Config.getDataDirectory(), 'sessions.json'));
      this.app = Express.createServer({
        key: Fs.readFileSync(Config.getCertFile()),
        cert: Fs.readFileSync(Config.getCertFile())
      });
      this.app.use(Express.cookieParser());
      this.app.use(Express.bodyParser());
      this.app.use(Express.methodOverride());
      this.app.use(Passport.initialize());
      this.app.use(Express["static"](__dirname + '/../../web'));
      this.app.set('views', __dirname + '/../../web');
      this.app.set('view engine', 'html.eco');
      this.app.register('.html.eco', require('eco'));
      this.app.get('/', function(req, res) {
        return res.render('index', {
          layout: false,
          num_clients: _this.clients.length,
          num_connections: _this.connections.length
        });
      });
      this.app.post('/login', function(req, res, next) {
        var auth;
        req.body.username = 'ignore';
        auth = Passport.authenticate('local', function(err, user, info) {
          var response, sessionId;
          if (err) {
            return next(err);
          }
          if (!user) {
            response = {
              success: false,
              message: info.message
            };
            res.writeHead(401, {
              'Content-Type': 'application/json'
            });
            res.end(JSON.stringify(response));
          }
          if (user) {
            sessionId = Crypto.randomBytes(32).toString('hex');
            _this.sessions.set(sessionId, {});
            response = {
              success: true,
              session: sessionId
            };
            res.writeHead(200, {
              'Content-Type': 'application/json'
            });
            return res.end(JSON.stringify(response));
          }
        });
        return auth(req, res, next);
      });
      this.app.addListener('upgrade', function(request, socket, head) {
        var res;
        request.method = 'UPGRADE';
        res = new Http.ServerResponse(request);
        return _this.app.handle(request, res, function() {
          var ws;
          if (_this.sessions.get(request.cookies.session)) {
            ws = new WebSocket(request, socket, head);
            Log.info('websocket client: connected');
            return _this.addClient(ws);
          } else {
            console.log('unauthorized');
            return request.socket.end('HTTP/1.1 401 Unauthorized\r\n\r\n');
          }
        });
      });
      return this.app.listen(port, function() {
        console.log("\nTapChat ready at https://localhost:" + port + "\n");
        if (callback) {
          return callback(_this);
        }
      });
    };

    Engine.prototype.addClient = function(client) {
      var _this = this;
      client.sendQueue = new WorkingQueue(1);
      this.clients.push(client);
      client.onmessage = function(event) {
        var callback, handler, message;
        message = JSON.parse(event.data);
        if (!message._reqid) {
          Log.error('Missing _reqid, ignoring message', event.data);
          return;
        }
        Log.silly('Got message:', event.data);
        callback = function(reply) {
          return _this.send(client, {
            _reqid: message._reqid,
            msg: merge(reply, {
              success: true
            })
          });
        };
        if (handler = _this.messageHandlers[message._method]) {
          try {
            return handler.apply(_this, [client, message, callback]);
          } catch (error) {
            Log.error("Error handling message", {
              message: event.data,
              error: error.stack
            });
            return client.close();
          }
        } else {
          return Log.warn("No handler for " + message._method);
        }
      };
      client.onclose = function(event) {
        var index;
        Log.info('websocket client: disconnected', {
          code: event.code,
          reason: event.reason
        });
        index = _this.clients.indexOf(client);
        return _this.clients.splice(index, 1);
      };
      return this.sendBacklog(client);
    };

    Engine.prototype.send = function(client, message, cb) {
      var json,
        _this = this;
      message = this.prepareMessage(message);
      json = JSON.stringify(message);
      Log.silly('CLIENT SEND:', json);
      client.sendQueue.perform(function(over) {
        return client.send(json, cb ? cb() : void 0, over());
      });
      return message;
    };

    Engine.prototype.prepareMessage = function(message) {
      var now;
      now = parseInt(Date.now() / 1000);
      if (!message.time) {
        message.time = now;
      }
      if (!message.highlight) {
        message.highlight = false;
      }
      if (!message.eid) {
        message.eid = -1;
      }
      return message;
    };

    Engine.prototype.addConnection = function(options) {
      var _this = this;
      return new Connection(this, options, function(conn) {
        _this.connections.push(conn);
        conn.addListener('event', function(event) {
          return _this.broadcast(event);
        });
        return conn.sendBacklog(null, function() {
          if (conn.autoConnect) {
            return conn.connect();
          }
        });
      });
    };

    Engine.prototype.removeConnection = function(conn, cb) {
      var _this = this;
      return conn["delete"](function() {
        _this.connections.splice(_this.connections.indexOf(conn), 1);
        _this.broadcast(B.connectionDeleted(conn));
        return cb();
      });
    };

    Engine.prototype.findConnection = function(cid) {
      var conn, _i, _len, _ref1;
      _ref1 = this.connections;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        if (conn.id === cid) {
          return conn;
        }
      }
      return null;
    };

    Engine.prototype.broadcast = function(message, cb) {
      var client, queue, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(this.clients.length + 1);
      Log.silly('BROADCAST', JSON.stringify(message));
      if (!message.is_backlog) {
        if (message.highlight) {
          queue.perform(function(over) {
            return _this.pushClient.sendPush(message, over);
          });
        }
      }
      _ref1 = this.clients;
      _fn = function(client) {
        return queue.perform(function(over) {
          return _this.send(client, message, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        client = _ref1[_i];
        _fn(client);
      }
      queue.whenDone(function() {
        if (cb) {
          return cb();
        }
      });
      queue.doneAddingJobs();
      return message;
    };

    Engine.prototype.sendBacklog = function(client) {
      var conn, queue, _fn, _i, _len, _ref1,
        _this = this;
      queue = new WorkingQueue(1);
      queue.perform(function(over) {
        return _this.send(client, {
          type: 'header',
          version: Config.getAppVersion(),
          idle_interval: 29000,
          push_id: _this.pushId,
          push_key: Base64.urlEncode(_this.pushKey)
        }, over);
      });
      _ref1 = this.connections;
      _fn = function(conn) {
        return queue.perform(function(over) {
          return conn.sendBacklog(client, over);
        });
      };
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        conn = _ref1[_i];
        _fn(conn);
      }
      queue.whenDone(function() {
        return _this.send(client, {
          type: 'backlog_complete'
        });
      });
      return queue.doneAddingJobs();
    };

    Engine.prototype.messageHandlers = {
      heartbeat: function(client, message, callback) {
        var bid, buffer, buffers, cid, connection, eid, queue, seenEids, _fn,
          _this = this;
        this.selectedBid = message.selectedBuffer;
        seenEids = JSON.parse(message.seenEids);
        queue = new WorkingQueue(1);
        for (cid in seenEids) {
          buffers = seenEids[cid];
          connection = this.findConnection(parseInt(cid));
          if (!connection) {
            throw "connection not found: " + cid;
          }
          _fn = function(buffer, eid) {
            return queue.perform(function(over) {
              return buffer.setLastSeenEid(eid, over);
            });
          };
          for (bid in buffers) {
            eid = buffers[bid];
            buffer = connection.findBuffer(parseInt(bid));
            if (!buffer) {
              throw "buffer not found: " + bid;
            }
            _fn(buffer, eid);
          }
        }
        queue.whenDone(function() {
          return _this.db.getAllLastSeenEids(function(updatedSeenEids) {
            return _this.send(client, {
              type: 'heartbeat_echo',
              seenEids: updatedSeenEids
            });
          });
        });
        return queue.doneAddingJobs();
      },
      say: function(client, message, callback) {
        var conn, text, to;
        conn = this.findConnection(message.cid);
        to = message.to;
        text = message.msg;
        if (text) {
          conn.say(to, text);
          return;
        }
        return conn.getOrCreateBuffer(to, 'conversation', function(buffer, created) {
          return callback({
            name: to,
            cid: conn.id,
            type: 'open_buffer',
            _reqid: message._reqid
          });
        });
      },
      join: function(client, message, callback) {
        var chan, conn;
        chan = message.channel;
        conn = this.findConnection(message.cid);
        conn.join(chan);
        return callback({
          name: chan,
          cid: conn.id,
          type: 'open_buffer'
        });
      },
      part: function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        conn.part(message.channel);
        return callback();
      },
      disconnect: function(client, message, callback) {
        return this.findConnection(message.cid).disconnect(function() {
          return callback();
        });
      },
      reconnect: function(client, message, callback) {
        var _this = this;
        return this.findConnection(message.cid).reconnect(function() {
          return callback();
        });
      },
      'add-server': function(client, message, callback) {
        var _this = this;
        return this.db.insertConnection(message, function(info) {
          _this.addConnection(info);
          return callback();
        });
      },
      'edit-server': function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        return conn.edit(message, callback);
      },
      'delete-connection': function(client, message, callback) {
        var conn;
        conn = this.findConnection(message.cid);
        return this.removeConnection(conn, callback);
      },
      'archive-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.archive(callback);
      },
      'unarchive-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer.unarchive(callback);
      },
      'delete-buffer': function(client, message, callback) {
        var buffer, conn;
        conn = this.findConnection(message.cid);
        buffer = conn.findBuffer(message.id);
        return buffer["delete"](callback);
      }
    };

    return Engine;

  })();

  module.exports = Engine;

}).call(this);
