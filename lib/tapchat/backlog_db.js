// Generated by CoffeeScript 1.3.3
(function() {
  var BacklogDB, CoffeeScript, Config, DBMigrator, Fs, Path, SCHEMA_VERSION, Sqlite3, Squel, compact, count, del, ends, extend, flatten, last, merge, starts, _, _ref;

  Path = require('path');

  Fs = require('fs');

  Squel = require('squel');

  Sqlite3 = require('sqlite3').verbose();

  _ = require('underscore');

  Config = require('./config');

  DBMigrator = require('./db_migrator');

  CoffeeScript = require('coffee-script');

  _ref = CoffeeScript.helpers, starts = _ref.starts, ends = _ref.ends, compact = _ref.compact, count = _ref.count, merge = _ref.merge, extend = _ref.extend, flatten = _ref.flatten, del = _ref.del, last = _ref.last;

  SCHEMA_VERSION = 4;

  BacklogDB = (function() {

    function BacklogDB(engine, callback) {
      var migrationsDir,
        _this = this;
      this.file = Path.join(Config.getDataDirectory(), 'backlog.db');
      migrationsDir = __dirname + '../../../db';
      this.db = new Sqlite3.Database(this.file, function() {
        var m;
        m = new DBMigrator({
          db: _this.db,
          dir: migrationsDir
        });
        return m.migrate(SCHEMA_VERSION, callback);
      });
    }

    BacklogDB.prototype.selectConnections = function(callback) {
      return this.db.all('SELECT * FROM connections', function(err, rows) {
        if (err) {
          throw err;
        }
        return callback(rows);
      });
    };

    BacklogDB.prototype.selectConnection = function(cid, callback) {
      return this.db.get('SELECT * FROM connections WHERE cid = $cid', {
        $cid: cid
      }, function(err, row) {
        if (err) {
          throw err;
        }
        return callback(row);
      });
    };

    BacklogDB.prototype.selectBuffers = function(cid, callback) {
      return this.db.all('SELECT * FROM buffers WHERE cid = $cid', {
        $cid: cid
      }, function(err, rows) {
        if (err) {
          throw err;
        }
        return callback(rows);
      });
    };

    BacklogDB.prototype.insertConnection = function(options, callback) {
      var self, _ref1;
      if (_.isEmpty(options.hostname)) {
        throw 'hostname is required';
      }
      if (!(parseInt(options.port) > 0)) {
        throw 'port is required';
      }
      if (_.isEmpty(options.nickname)) {
        throw 'nickname is required';
      }
      if (_.isEmpty(options.realname)) {
        throw 'realname is required';
      }
      self = this;
      return this.db.run("INSERT INTO connections (name, server, port, is_ssl, nick, user_name, real_name, server_pass)\nVALUES ($name, $server, $port, $is_ssl, $nick, $user_name, $real_name, $server_pass)", {
        $name: (_ref1 = options.name) != null ? _ref1 : options.hostname,
        $server: options.hostname,
        $port: options.port,
        $nick: options.nickname,
        $user_name: options.nickname,
        $real_name: options.realname,
        $server_pass: options.server_pass,
        $is_ssl: options.ssl || false
      }, function(err) {
        if (err) {
          throw err;
        }
        return self.selectConnection(this.lastID, function(row) {
          return callback(row);
        });
      });
    };

    BacklogDB.prototype.updateConnection = function(cid, options, callback) {
      var isSSL, name, self, setAttribute, sql,
        _this = this;
      self = this;
      sql = Squel.update().table('connections');
      sql.where('cid = $cid');
      setAttribute = function(name, value) {
        if (value && value !== void 0) {
          return sql.set(name, value);
        }
      };
      name = !_.isEmpty(options.name) ? options.name : options.hostname;
      setAttribute('name', name);
      setAttribute('server', options.hostname);
      setAttribute('port', options.port);
      setAttribute('nick', options.nickname);
      setAttribute('user_name', options.nickname);
      setAttribute('real_name', options.realname);
      setAttribute('ssl_fingerprint', options.ssl_fingerprint);
      if (_.has(options, 'ssl')) {
        isSSL = !!Number(options.ssl) ? 1 : 0;
        sql.set('is_ssl', isSSL);
      }
      setAttribute('server_pass', options.server_pass);
      return this.db.run(sql.toString(), {
        $cid: cid
      }, function(err) {
        if (err) {
          throw err;
        }
        return self.selectConnection(cid, function(row) {
          return callback(row);
        });
      });
    };

    BacklogDB.prototype.deleteConnection = function(cid, callback) {
      var params,
        _this = this;
      params = {
        $cid: cid
      };
      return this.db.serialize(function() {
        _this.db.run('BEGIN TRANSACTION');
        _this.db.run('DELETE FROM events      WHERE bid IN (SELECT bid FROM buffers WHERE cid = $cid)', params);
        _this.db.run('DELETE FROM buffers     WHERE cid = $cid', params);
        _this.db.run('DELETE FROM connections WHERE cid = $cid', params);
        return _this.db.run('COMMIT', function(err) {
          if (err) {
            throw err;
          }
          return callback();
        });
      });
    };

    BacklogDB.prototype.insertBuffer = function(cid, name, type, callback) {
      var autoJoin;
      autoJoin = type === 'channel';
      return this.db.run('INSERT INTO buffers (cid, name, type, auto_join) VALUES ($cid, $name, $type, $auto_join)', {
        $cid: cid,
        $name: name,
        $type: type,
        $auto_join: autoJoin
      }, function(err) {
        if (err) {
          throw err;
        }
        return callback({
          cid: cid,
          bid: this.lastID,
          name: name,
          type: type
        });
      });
    };

    BacklogDB.prototype.deleteBuffer = function(cid, bid, callback) {
      var _this = this;
      return this.db.serialize(function() {
        _this.db.run('BEGIN TRANSACTION');
        _this.db.run('DELETE FROM events WHERE bid = $bid', {
          $bid: bid
        });
        _this.db.run('DELETE FROM buffers WHERE cid = $cid AND bid = $bid', {
          $cid: cid,
          $bid: bid
        });
        return _this.db.run('COMMIT', function(err) {
          if (err) {
            throw err;
          }
          return callback();
        });
      });
    };

    BacklogDB.prototype.insertEvent = function(event, callback) {
      var query;
      query = "INSERT INTO events (bid, data)\nVALUES ($bid, $data)";
      return this.db.run(query, {
        $bid: event.bid,
        $data: JSON.stringify(event)
      }, function(err) {
        if (err) {
          throw err;
        }
        return callback(merge({
          eid: this.lastID
        }, event));
      });
    };

    BacklogDB.prototype.selectEvents = function(bid, callback) {
      var query;
      query = "SELECT eid, bid, data, created_at\nFROM events\nWHERE eid IN (\n    SELECT eid\n    FROM EVENTS\n    WHERE bid = $bid\n    ORDER BY eid DESC\n    LIMIT $limit\n)\nORDER BY eid ASC";
      return this.db.all(query, {
        $bid: bid,
        $limit: 50
      }, function(err, rows) {
        if (err) {
          throw err;
        }
        return callback(rows);
      });
    };

    BacklogDB.prototype.getAllLastSeenEids = function(callback) {
      var query;
      query = "SELECT cid, bid, last_seen_eid FROM buffers WHERE last_seen_eid IS NOT NULL";
      return this.db.all(query, function(err, rows) {
        var bid, cid, eid, result, row, _i, _len, _ref1;
        if (err) {
          throw err;
        }
        result = {};
        for (_i = 0, _len = rows.length; _i < _len; _i++) {
          row = rows[_i];
          cid = parseInt(row.cid);
          bid = parseInt(row.bid);
          eid = parseInt(row.last_seen_eid);
          if ((_ref1 = result[cid]) == null) {
            result[cid] = {};
          }
          result[cid][bid] = eid;
        }
        return callback(result);
      });
    };

    BacklogDB.prototype.setBufferLastSeenEid = function(cid, bid, eid, callback) {
      var query;
      query = "UPDATE buffers\nSET last_seen_eid = $eid,\nupdated_at = $time\nWHERE cid = $cid AND bid = $bid";
      return this.db.run(query, {
        $eid: eid,
        $cid: cid,
        $bid: bid,
        $time: new Date().getTime()
      }, function(err) {
        if (err) {
          throw err;
        }
        return callback();
      });
    };

    BacklogDB.prototype.setBufferArchived = function(cid, bid, archived, callback) {
      var query;
      query = "UPDATE buffers\nSET archived = $archived,\nupdated_at = $time\nWHERE cid = $cid AND bid = $bid";
      return this.db.run(query, {
        $cid: cid,
        $bid: bid,
        $archived: (archived ? 1 : 0),
        $time: new Date().getTime()
      }, function(err) {
        if (err) {
          throw err;
        }
        return callback();
      });
    };

    BacklogDB.prototype.setBufferAutoJoin = function(cid, bid, autoJoin, callback) {
      var query;
      query = "UPDATE buffers\nSET auto_join = $auto_join,\nupdated_at = $time\nWHERE cid = $cid AND bid = $bid";
      return this.db.run(query, {
        $cid: cid,
        $bid: bid,
        $auto_join: autoJoin,
        $time: new Date().getTime()
      }, function(err) {
        if (err) {
          throw err;
        }
        return callback();
      });
    };

    return BacklogDB;

  })();

  module.exports = BacklogDB;

}).call(this);
